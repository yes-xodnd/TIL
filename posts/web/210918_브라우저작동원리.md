# 브라우저의 작동 원리

지난 번에는 웹 브라우저의 일반적인 구성 요소, 주요 브라우저들과 각각의 엔진에 대해 알아보았습니다. 이번에는 크롬 브라우저를 중심으로 브라우저가 어떻게 구성되고 작동하는지 정리해보았습니다.

## 1. 멀티 프로세스 아키텍처

구글 크롬은 2013년, Webkit을 포크하여 만든 Blink 엔진을 사용하고 있습니다. 구글은 자신들의 오픈소스 브라우저 프로젝트인 chromium을 바탕으로 크롬 브라우저를 만들고 있는데, chromium의 멀티 프로세스 아키텍처에 더 적합한 렌더링 엔진을 만들고자 한 것입니다.

[크롬의 멀티 프로세스 아키텍처 도식도]

![browser architecture](https://developers.google.com/web/updates/images/inside-browser/part1/browser-arch2.png)

각 프로세스는 다음과 같은 역할을 합니다.

| 프로세스 | 역할                                                        |
| -------- | ----------------------------------------------------------- |
| 브라우저 | UI(주소창, 뒤로/앞으로 버튼 등), 네트워크 요청, 파일 액세스 |
| 렌더러   | 웹사이트가 렌더링 될 때 탭 안의 모든 것                     |
| 플러그인 | 플래시 등 웹사이트의 플러그인                               |
| GPU      | GPU 작업 제어                                               |

실제로 실행되는 프로세스는 크롬에서 메뉴 - 도구 더보기 - 작업 관리자 (Shift + ESC)를 열어 확인할 수 있습니다.

크롬은 보통 하나의 탭마다 하나의 렌더러 프로세스를 생성해 할당하게 되는데, 이를 통해 하나의 탭이 무응답 상태가 되더라도 다른 탭은 정상적으로 이용할 수 있게 됩니다. 

또한 스레드처럼 메모리를 공유하지 않기 때문에 보안에서도 장점을 가집니다. 이러한 특징은 메모리 사용량이 많아진다는 단점으로 이어지는데, 크롬은 생성되는 프로세스 개수에 제한을 두어 이러한 단점을 상쇄합니다. 컴퓨터 성능에 따라 달라지는 제한 갯수보다 많은 프로세스가 생성되면, 새로운 탭은 기존의 프로세스에서 실행됩니다.



## 2. 주소창에 URL을 입력하면 생기는 일

URL를 입력하고, HTML 문서를 응답받아 렌더링하는 과정입니다. 주소창은 브라우저 프로세스의 UI 스레드의 영역이므로, 브라우저 프로세스에서 시작합니다. 

### 2.1. 입력 처리

크롬의 주소창은 검색창도 겸하기 때문에, 검색어인지 URL인지 판단합니다. 검색 기록이나 탐색 기록을 목록으로 표시해주기도 합니다.

### 2.2. 탐색 시작

URL을 입력하고 엔터를 누르면, 브라우저 프로세스의 네트워크 요청을 위해 네트워크 스레드를 초기화합니다. 

### 2.3. 응답 읽기

응답의 바디(payload)가 들어오기 시작하면, 네트워크 스레드가 스트림의 처음 몇 바이트를 읽어 MIME Type 스니핑을 수행합니다. HTTP 헤더에 작성된 content-type과 같은 데이터인지 확인하는 작업입니다.

데이터가 HTML파일임을 확인하면, 요청한 렌더러 프로세스에게 데이터를 전달합니다. 

### 2.4. 페이지 로딩

렌더러 프로세스는 네트워크 스레드로부터 IPC를 통해 HTML 데이터를 전달받습니다. 한편 UI 스레드는 탐색하는 주소의 사이트 정보를 반영해 업데이트됩니다.

## 3. 렌더러 프로세스의 내부 동작

렌더러 프로세스의 핵심 역할은 HTML, CSS, 자바스크립트 데이터를 사용자가 상호작용할 수 있는 웹 페이지로 만드는 것입니다. 이 작업은 대부분 메인 스레드에 의해 수행됩니다. 문서를 파싱하고 화면의 표시할 때 까지의 

### 3.1. 파싱

데이터의 문자열(HTML)을 파싱하여 DOM을 생성합니다. HTML 문서의 파싱 방법은 [HTML 표준](https://html.spec.whatwg.org/)에 명시되어 있습니다. 

### 3.2. 추가 리소스 로딩

대부분의 문서는 이미지, CSS, 자바스크립트와 같은 외부 리소스를 사용합니다. 외부 리소스는 네트워크를 통해 로드되어야 하므로, 네트워크 스레드에게 요청을 보냅니다.

크롬은 사전 로드 스캐너를 통해 추가 리소스 로딩의 속도를 높입니다. 파싱하면서 `img`, `link`와 같은 요소가 있다면, 해당 요소의 토큰들을 미리 확인해 요청을 보내는 작업입니다.

자바스크립트는 문서의 구조(DOM)을 조작할 수 있으므로, HTML 문서 파싱 중에 `script` 태그를 발견하면 HTML 파서는 작업을 중단하고 스크립트의 로드, 파스, 실행이 완료될 때까지 대기합니다.

`script` 태그에 `defer` 속성을 적용하면, 미리 다운로드하고 문서가 화면에 출력된 후에 해당 자바스크립트 코드를 파싱하고 실행하게 할 수 있습니다. 

현재 페이지에서 사용될 것이 확실한 콘텐츠들은 `<link rel="preload">`를 통해 브라우저에게 먼저 다운받도록 할 수 있습니다.

### 3.3. 스타일 계산

메인 스레드는 CSS 파일들을 파싱하여 CSSOM을 생성하고, DOM과 결합하여 렌더링 트리를 생성합니다. 브라우저가 문서 노드들의 구조와 각 노드의 스타일을 알게 되었으므로, 이제 위치를 계산하고 화면에 표시하는 작업을 수행할 수 있습니다.

### 3.4. 레이아웃

메인 스레드는 렌더링 트리를 순회하며, 뷰포트 내에각 요소들의 정확한 위치와 크기를 절대적인 픽셀 단위로 계산합니다. 이를 레이아웃이라고 하며, 레이아웃 작업을 다시 실행하는 경우 리플로우라고 표현합니다. 

### 3.5. 페인트

메인 스레드는 레이아웃 결과를 가지고 어떤 순서로 페인트 작업을 수행할지 결정하는 페인트 기록을 생성하고, 화면에 픽셀을 표시하는 작업을 실행합니다. 

페인트 기록을 픽셀로 표시하는 작업을 래스터라이징이라고 합니다. 이는 렌더러 프로세스의 래스터 스레드가 수행합니다. 이전에는 뷰포트에 포함되는 영역만 래스터라이징했지만, 최근에는 컴포지팅이라는 기술을 활용합니다.

컴포지팅은 페이지의 여러 부분들을 여러 레이어로 나누고, 이를 각각 래스터하며 컴포지터 스레드에서 페이지를 합성하는 기술입니다. 컴포지팅은 메인 스레드의 개입 없이 수행되므로 컴포지팅만 하는 애니메이션은 일반적으로 부드러운 성능을 위한 가장 좋은 방법으로 여겨집니다. 하지만 많은 수의 레이어에 대해 컴포지팅 하는 것은 매번 새로 추가 래스터라이징을 하는 것보다 느린 작업이므로 적절한 숫자의 레이어를 유지하는 것이 성능에 중요합니다. 웹 페이지의 레이어 상태는 개발자 도구 - 메뉴 - More Tools - Layers에서 확인할 수 있습니다.



## 5. 출처

>- [Google Developers - 모던 웹 브라우저 들여다보기](https://developers.google.com/web/updates/2018/09/inside-browser-part1)
>- [Google Developers - 렌더링 트리 생성, 레이아웃 및 페인트](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=ko)
>- [chromium.org Developer FAQ - Why Blink?](http://www.chromium.org/blink/developer-faq)